1. 特徵根的獲取與數值校正在數學上，特徵方程的根是精確的，但在電腦運算中，numpy.roots 是透過數值演算法（如特徵值分解）求得的，這會產生微小的浮點數誤差。為何要 Rounding？例如 $y'' - 4y' + 4y = 0$ 的根應該是 $[2, 2]$，但電腦可能算出 $[2.00000001, 1.99999999]$。如果不做四捨五入（Rounding），程式會誤判為「兩個不同的實根」而非「一個二重根」。虛部判定：如果一個根的虛部極小（例如 $10^{-7}$），我們會強制將其視為實數，以避免在輸出中出現 0.000000001i 這種干擾項。
2. 根的分類與重數統計我們使用 collections.Counter 來統計每個根出現的次數（即「重數」$m$）。線性獨立解的生成原則：根據 ODE 理論，如果 $\lambda$ 是一個 $m$ 重根，則它貢獻的線性獨立解必須包含 $e^{\lambda x}, xe^{\lambda x}, \dots, x^{m-1}e^{\lambda x}$。使用 Counter 能讓我們一次性知道某個根需要生成多少個帶 $x^k$ 的項
3. 實數與複數的處理邏輯這是程式中最關鍵的分支點：實數根：直接映射為 $C_n x^k e^{\lambda x}$。複數根 (Euler's Formula)：複數根必以共軛形式 $\alpha \pm \beta i$ 成對出現。雖然理論上可以寫成複數指數 $e^{(\alpha + \beta i)x}$，但工程與物理應用中更偏好實函數形式：$\text{Real part } (\alpha) \rightarrow \text{控制增長或衰減的 } e^{\alpha x}$$\text{Imaginary part } (\beta) \rightarrow \text{控制振盪的 } \cos(\beta x) \text{ 與 } \sin(\beta x)$避免重複處理：程式在處理完 $\alpha + \beta i$ 後，會自動將其共軛夥伴 $\alpha - \beta i$ 加入「已處理清單」，防止同一個解被印出兩次。
4. 輸出字串的優化為了讓結果看起來像「教科書」，程式做了以下細節處理：$x$ 的次方顯示：當 $m=0$ 時不顯示 $x$，當 $m=1$ 時顯示 $x$ 而非 $x^1$。指數部分：當實部 $\alpha=0$ 時，隱藏 $e^{0x}$（因為等於 1），只留下三角函數部分。自動編號：使用 term_index 確保積分常數 $C_1, C_2, \dots$ 是連續遞增的。

